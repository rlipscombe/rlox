use std::str::FromStr;
use crate::ast::*;

grammar;

match {
    // Ignore C++-style comments
    r"//[^\n\r]*[\n\r]*" => {}
}
else {
    r"\s*" => {},
    _
}

pub Program = Declaration*;

Declaration: Stmt = { VarDecl, Statement, }
VarDecl: Stmt = {
    "var" <i:Identifier> "=" <e:Expr> ";" => Stmt::VarDecl(i.to_string(), e),
    "var" <i:Identifier> ";" => Stmt::VarDecl(i.to_string(), Expr::Nil),
}

pub Statement = {
    ExprStmt,
    IfStmt,
    PrintStmt,
    WhileStmt,
    AssertStmt,
    Block
}

ExprStmt: Stmt = <Expr> ";" => Stmt::Expr(<>);
PrintStmt: Stmt = "print" <Expr> ";" => Stmt::Print(<>);
AssertStmt: Stmt = "assert" <s:@L> <expr:Expr> <e:@L>";" => Stmt::Assert{ expr: expr, location: location(s, e) };
Block: Stmt = "{" <Declaration*> "}" => Stmt::Block(<>);

// To avoid ambiguity in the grammar (see https://github.com/lalrpop/lalrpop/issues/386),
// we'll require that the 'if' statement take block statements.
IfStmt: Stmt = {
    "if" "(" <cond:Expr> ")" <then:Block>
        => Stmt::If{ cond: cond, then: Box::new(then), else_: Box::new(Stmt::Empty) },
    "if" "(" <cond:Expr> ")" <then:Block> "else" <else_:Block>
        => Stmt::If{ cond: cond, then: Box::new(then), else_: Box::new(else_) }
}

// For consistency, we'll require that the 'while' statement also take block statements.
// TODO: When we allow 'if' to take plain statements, we should fix this as well.
WhileStmt: Stmt =
    "while" "(" <cond:Expr> ")" <body:Block>
        => Stmt::While{ cond: cond, body: Box::new(body) };

pub Expr = Assignment;

Assignment: Expr = {
    <s:@L> <i:Identifier> <e:@L> "=" <a:Assignment> => Expr::Assignment { name: i.to_string(), rhs: Box::new(a), location: location(s, e) },
    Equality
}

Equality = BinaryOperator<Equality, EqualityOp, Comparison>;
Comparison = BinaryOperator<Comparison, ComparisonOp, Addition>;
Addition = BinaryOperator<Addition, AdditionOp, Multiplication>;
Multiplication = BinaryOperator<Multiplication, MultiplicationOp, Unary>;
Unary = UnaryOperator<UnaryOp, Unary, Term>;

EqualityOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
}

ComparisonOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Le,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Ge,
}

AdditionOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

MultiplicationOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Invert,
    "-" => UnaryOp::Negate,
}

Term: Expr = {
    Num => Expr::Number(<>),
    Bool => Expr::Boolean(<>),
    "nil" => Expr::Nil,
    String => Expr::String(<>),
    "(" <Expr> ")",
    <s:@L> <i:Identifier> <e:@L> => Expr::Var { name: i.to_string(), location: location(s, e) },
};

Num: f64 = r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}

// TODO: Support escape characters.
String: String = <s:r#""[^"]*""#> => (s[1..s.len()-1]).to_string();

Identifier = r#"[a-zA-Z_][a-zA-Z_0-9]*"#;

// Helpers
UnaryOperator<Operator, Right, Next>: Expr = {
    <op:Operator> <right:Right> => Expr::Unary(op, Box::new(right)),
    Next
}

BinaryOperator<Left, Operator, Right>: Expr = {
    <left:Left> <op:Operator> <right:Right> => Expr::Binary(Box::new(left), op, Box::new(right)),
    Right
}
