use std::str::FromStr;
use crate::ast::*;

grammar;

match {
    // Ignore C++-style comments
    r"//[^\n\r]*[\n\r]*" => {}
}
else {
    r"\s*" => {},
    _
}

pub Program = Declaration*;

Declaration: Stmt = { VarDecl, Statement, }
VarDecl: Stmt = {
    "var" <i:Identifier> "=" <e:Expr> ";" => Stmt::VarDecl(i.to_string(), Box::new(e)),
    "var" <i:Identifier> ";" => Stmt::VarDecl(i.to_string(), Box::new(Expr::Nil)),
}

pub Statement = { ExprStmt, PrintStmt, }
ExprStmt: Stmt = <Expr> ";" => Stmt::Expr(Box::new(<>));
PrintStmt: Stmt = "print" <Expr> ";" => Stmt::Print(Box::new(<>));

pub Expr = Equality;
Equality = BinaryOperator<Equality, EqualityOp, Comparison>;
Comparison = BinaryOperator<Comparison, ComparisonOp, Addition>;
Addition = BinaryOperator<Addition, AdditionOp, Multiplication>;
Multiplication = BinaryOperator<Multiplication, MultiplicationOp, Unary>;
Unary = UnaryOperator<UnaryOp, Unary, Term>;

EqualityOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
}

ComparisonOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Le,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Ge,
}

AdditionOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

MultiplicationOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
}

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Invert,
    "-" => UnaryOp::Negate,
}

Term: Expr = {
    Num => Expr::Number(<>),
    Bool => Expr::Boolean(<>),
    "nil" => Expr::Nil,
    String => Expr::String(<>),
    "(" <Expr> ")",
    <s:@L> <i:Identifier> <e:@L> => Expr::Var { name: i.to_string(), location: location(s, e) },
};

Num: f64 = r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}

// TODO: Support escape characters.
String: String = <s:r#""[^"]*""#> => (s[1..s.len()-1]).to_string();

Identifier = r#"[a-zA-Z_][a-zA-Z_0-9]*"#;

// Helpers
UnaryOperator<Operator, Right, Next>: Expr = {
    <op:Operator> <right:Right> => Expr::Unary(op, Box::new(right)),
    Next
}

BinaryOperator<Left, Operator, Right>: Expr = {
    <left:Left> <op:Operator> <right:Right> => Expr::Binary(Box::new(left), op, Box::new(right)),
    Right
}
